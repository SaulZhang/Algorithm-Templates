#### 用时(02:43:49)

#### 每道题遇到的问题和收获
- 1152:求素数，判断k和n条件的地方有坑(启示：多有一些边界的问题，需要进行特殊的判断和处理，特别是不同的变脸之间的关系)

- 1153:模型字符串的处理和排序，有两个用例容易超时，这两个用例还是很有启示的.<br>
      首先学会的第一个技巧就是，通过注释不同部分的代码，来测试具体是那一部分超时了。<br>
      第二个技巧就是，要避免整体的遍历，采用更好的索引结构来进行存储。这里专门讲讲case3和case4.<br>
      case4经过测试是在type 1处理的时候超时了，由于一开始采用的是遍历整体的样本一遍 ，找出指定level的所有考生信息再进行排序。这样的话整体遍历的话显然很费时间，因此在这里可以考虑分为三个等级，在输入的时候就用三个vector来存。然后在type1处理的时候只需要拿指定的那个vector来处理就行啦。[虽然这样知识常数级别的优化，但是当常数的规模很大的时候，还是能有不少的提升的]<br>
      case3经过测试是在type 3处理的时候超时了，由于一开始采用的是遍历整体的样本一遍 ，统计指定date的指定site的考生数量。这样的话整体遍历的话显然很费时间，因此这里可以在输入的时候就先简历一个二级索引，data为第一级索引，site为第二级索引,value为考生的数量。索引表定义如下：map<map<string,int>>。<br>
      这道题卡超时的边界比较严格下面可以算一算。
      题目的时限时200ms≈1e7，记录的数量N≤10000，查询的个数M≤100，那么最坏情况下的复杂度就是NMlog2(N)≈1.3e7>1e7,超出了一丁点。所以做一些常数级别上的优化还是有望多点一小部分样例的。

- 1154:dfs判断相邻结点是否相同

- 1155:求给定的树从树根到叶子的所有路径，并判断是否为堆结构


- 总体而言，第二题想拿满分画了比较长的时间。第三第四题是树和图的构建和遍历相关反而比较简单，已有思路基本就能一次性过掉。
